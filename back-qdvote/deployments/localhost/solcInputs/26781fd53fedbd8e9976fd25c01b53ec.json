{
  "language": "Solidity",
  "sources": {
    "contracts/Factory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.4.0 <0.9.0;\nimport \"./Poll.sol\";\n\ncontract Factory {\n    Poll[] public PollArray;\n    bool[] public isActive;\n    uint256[] public results;\n    event PollCreated(string _title);\n    //dummy for creating tx to keep block in localhost moving wen getResult.\n    uint256 dummy = 0;\n\n    function createPoll(\n        string memory _title,\n        address[] memory _eligibles,\n        string[] memory _opTitle,\n        uint256 _validMinutes\n    ) public {\n        PollArray.push(new Poll(msg.sender, _title, _eligibles, _opTitle, _validMinutes));\n        emit PollCreated(_title);\n        isActive.push(true);\n        results.push(0);\n    }\n\n    function positiveVote(uint256 _pollIndex, uint256 _optionIndex, uint256 _num) public {\n        require(isActive[_pollIndex] == true, \"Time's up for this poll already!\");\n        PollArray[_pollIndex].positiveVote(msg.sender, _optionIndex, _num);\n    }\n\n    function negativeVote(uint256 _pollIndex, uint256 _optionIndex, uint256 _num) public {\n        require(isActive[_pollIndex] == true, \"Time's up for this poll already!\");\n        PollArray[_pollIndex].negativeVote(msg.sender, _optionIndex, _num);\n    }\n\n    function publishResult(uint _pollIndex) public {\n        // To make sure a transaction happens to append the block, hence its time in\n        // our hardhat localhost.\n        dummy += 1;\n        results[_pollIndex] = PollArray[_pollIndex].getResult();\n        isActive[_pollIndex] = false;\n    }\n\n    function getNumEvents() public view returns (uint256) {\n        return PollArray.length;\n    }\n\n    function getTitle(uint256 _pollIndex) public view returns (string memory) {\n        return PollArray[_pollIndex].title();\n    }\n\n    function getOpTitle(uint256 _pollIndex, uint256 optionId) public view returns (string memory) {\n        return PollArray[_pollIndex].getOpTitle(optionId);\n    }\n\n    function getOpPositiveWeight(\n        uint256 _pollIndex,\n        uint256 optionId\n    ) public view returns (uint256) {\n        return PollArray[_pollIndex].getOpPositiveWeight(optionId);\n    }\n\n    function getVoterOpPositiveWeight(\n        uint256 _pollIndex,\n        uint256 optionId\n    ) public view returns (uint256) {\n        return PollArray[_pollIndex].getVoterOpPositiveWeight(optionId, msg.sender);\n    }\n\n    function getOpNegativeWeight(\n        uint256 _pollIndex,\n        uint256 optionId\n    ) public view returns (uint256) {\n        return PollArray[_pollIndex].getOpNegativeWeight(optionId);\n    }\n\n    function getVoterOpNegativeWeight(\n        uint256 _pollIndex,\n        uint256 optionId\n    ) public view returns (uint256) {\n        return PollArray[_pollIndex].getVoterOpNegativeWeight(optionId, msg.sender);\n    }\n\n    function getCredit(uint256 _pollIndex, address voter) public view returns (uint256) {\n        return PollArray[_pollIndex].getCredit(voter);\n    }\n\n    function getresult(uint256 _pollIndex) public view returns (uint256) {\n        return PollArray[_pollIndex].getResult();\n    }\n\n    function getdeployTime(uint _pollIndex) public view returns (uint256) {\n        return PollArray[_pollIndex].deployTime();\n    }\n\n    function getcurrentTime() public view returns (uint256) {\n        return block.timestamp;\n    }\n\n    function getvalidSeconds(uint _pollIndex) public view returns (uint256) {\n        return PollArray[_pollIndex].validSeconds();\n    }\n\n    function getNumOptions(uint256 _pollIndex) public view returns (uint256) {\n        return PollArray[_pollIndex].optionCount();\n    }\n}\n"
    },
    "contracts/Poll.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.0 <0.9.0;\n\n//test\ncontract Poll {\n    struct Option {\n        string title;\n        mapping(address => uint256) positiveVotes; // user => weight\n        mapping(address => uint256) negativeVotes; // user => weight\n        uint256 totalPositiveWeight;\n        uint256 totalNegativeWeight;\n    }\n    uint256 public deployTime;\n    uint256 public validSeconds;\n    mapping(uint256 => Option) public options; //\n    uint256 public optionCount;\n\n    uint256 public creditLimit = 100;\n    uint256 public constant voteCost = 1; // base = 1 credit limit\n    mapping(address => uint256) public creditVoters;\n\n    address factory;\n    address public admin;\n    string public title;\n    address[] eligibles;\n\n    event Voted(uint256 optionId, uint256 weight, bool isPositive);\n\n    constructor(\n        address _admin,\n        string memory _title,\n        address[] memory _eligibles,\n        string[] memory _opTitle,\n        uint256 _validMinutes\n    ) {\n        factory = msg.sender;\n        admin = _admin;\n        title = _title;\n        eligibles = _eligibles;\n        optionCount = _opTitle.length;\n        deployTime = block.timestamp;\n        validSeconds = _validMinutes * 60;\n        for (uint i = 0; i < _eligibles.length; i++) {\n            creditVoters[_eligibles[i]] = creditLimit;\n        }\n        for (uint optionIndex = 0; optionIndex < _opTitle.length; optionIndex++) {\n            Option storage option = options[optionIndex];\n            option.title = _opTitle[optionIndex];\n        }\n    }\n\n    function calcCost(uint256 weight) public pure returns (uint256) {\n        return weight * weight * voteCost;\n    }\n\n    function existsEligible(address voter) public view returns (bool) {\n        for (uint i = 0; i < eligibles.length; i++) {\n            if (eligibles[i] == voter) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function calMaxNeg() public view returns (uint256) {\n        uint maxNeg = 0;\n        for (uint i = 0; i < optionCount; i++) {\n            if (options[i].totalNegativeWeight > maxNeg) {\n                maxNeg = options[i].totalNegativeWeight;\n            }\n        }\n        return maxNeg;\n    }\n\n    function positiveVote(address voter, uint256 optionId, uint256 weight) public payable {\n        require(msg.sender == factory, \"Not called via Fac\");\n        require(existsEligible(voter), \"Not Eligible\");\n\n        Option storage option = options[optionId];\n        bool positive = option.positiveVotes[voter] > 0 ? true : false;\n        uint256 currWeight = positive ? option.positiveVotes[voter] : option.negativeVotes[voter];\n        require(\n            creditVoters[voter] + calcCost(currWeight) >= calcCost(weight),\n            \"Not enough credit\"\n        );\n        creditVoters[voter] = creditVoters[voter] + calcCost(currWeight) - calcCost(weight);\n        option.positiveVotes[voter] = weight;\n        option.negativeVotes[voter] = 0;\n        if (positive) {\n            option.totalPositiveWeight = option.totalPositiveWeight + weight - currWeight;\n        } else {\n            option.totalPositiveWeight += weight;\n            option.totalNegativeWeight -= currWeight;\n        }\n        emit Voted(optionId, weight, true);\n    }\n\n    function negativeVote(address voter, uint256 optionId, uint256 weight) public payable {\n        require(msg.sender == factory, \"Not called via Fac\");\n        require(existsEligible(voter), \"Not eligible\");\n\n        Option storage option = options[optionId];\n        bool positive = option.positiveVotes[voter] > 0 ? true : false;\n        uint256 currWeight = positive ? option.positiveVotes[voter] : option.negativeVotes[voter];\n\n        require(\n            creditVoters[voter] + calcCost(currWeight) >= calcCost(weight),\n            \"Not enough credit\"\n        );\n        creditVoters[voter] = creditVoters[voter] + calcCost(currWeight) - calcCost(weight);\n        option.positiveVotes[voter] = 0;\n        option.negativeVotes[voter] = weight;\n        if (positive) {\n            option.totalPositiveWeight -= currWeight;\n            option.totalNegativeWeight += weight;\n        } else {\n            option.totalNegativeWeight = option.totalNegativeWeight + weight - currWeight;\n        }\n        emit Voted(optionId, weight, false);\n    }\n\n    function getOpTitle(uint optionId) public view returns (string memory) {\n        return options[optionId].title;\n    }\n\n    function getOpPositiveWeight(uint optionId) public view returns (uint256) {\n        return options[optionId].totalPositiveWeight;\n    }\n\n    function getOpNegativeWeight(uint optionId) public view returns (uint256) {\n        return options[optionId].totalNegativeWeight;\n    }\n\n    function getCredit(address voter) public view returns (uint256) {\n        return creditVoters[voter];\n    }\n\n    function getResult() public view returns (uint256) {\n        // Need condition to be called only when time expired\n        require(block.timestamp > deployTime + validSeconds, \"Poll time not expired yet!\");\n        uint winner = 0;\n        uint winnerAdjustedWeight = 0;\n        for (uint i = 0; i < optionCount; i++) {\n            if (\n                options[i].totalPositiveWeight + calMaxNeg() - options[i].totalNegativeWeight >\n                winnerAdjustedWeight\n            ) {\n                winner = i;\n                winnerAdjustedWeight =\n                    options[i].totalPositiveWeight +\n                    calMaxNeg() -\n                    options[i].totalNegativeWeight;\n            }\n        }\n        return winner;\n    }\n\n    function getVoterOpPositiveWeight(uint optionId, address voter) public view returns (uint256) {\n        return options[optionId].positiveVotes[voter];\n    }\n\n    function getVoterOpNegativeWeight(uint optionId, address voter) public view returns (uint256) {\n        return options[optionId].negativeVotes[voter];\n    }\n\n    function currentWeight(\n        uint256 optionId,\n        address addr,\n        bool isPositive\n    ) public view returns (uint256) {\n        if (isPositive) {\n            return options[optionId].positiveVotes[addr];\n        } else {\n            return options[optionId].negativeVotes[addr];\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}